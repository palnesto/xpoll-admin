
src/api/endpoints/index.ts
--------------------------
export const endpoints = {
  healthCheck: "/health-check",
  adminLogin: "/public/admin/login",
  adminLogout: "/public/admin/logout",
  adminMe: "/internal/auth/me",
  entities: {
    polls: {
      all: "/internal/poll/list",
      create: "/poll",
      getById: (id: string) => `/internal/poll/${id}`,
      delete: `/internal/poll`,
      edit: {
        details: `/internal/poll/details`,
        addOption: `/internal/poll/options`,
        editOption: `/internal/poll/options`,
        toggleOption: `/internal/poll/archive`,
      },
      getPollsByTrialId: (id: string) => `/internal/poll/trial/${id}`,
    },
    trials: {
      all: "/internal/trial/list",
      create: "/internal/trial",
      update: "/internal/trial",
      delete: "/internal/trial",
      getById: (id: string) => `/internal/trial/${id}`,
      addPollToTrial: (id: string) => `/internal/trial/${id}/polls`,
    },
    actions: {
      createMint: "/internal/actions/mint",
      createBurn: "/internal/actions/burn",
      createFund: "/internal/actions/fund",
      createWithdraw: "/internal/actions/withdraw",
      createSellApprove: "/internal/actions/bulk-sell-intent-approve",
      createSellReject: "/internal/actions/bulk-sell-intent-reject",
    },
    assetLedger: {
      all: "/internal/asset-ledger/all",
      systemReport: "/internal/asset-ledger/system/report",
      sellIntent: "/internal/asset-ledger/sell-intent",
      sellApproveOrder: "/internal/asset-ledger/sell-approve",
      sellRejectOrder: "/internal/asset-ledger/sell-reject",
    },
    slug: {
      create: "/internal/preference/slugs",
      all: "/internal/preference/slugs",
    },
  },
};


src/api/queryClient.ts
----------------------
import { appToast } from "@/utils/toast";
import { QueryClient, QueryFunctionContext } from "@tanstack/react-query";
import axios from "axios";

export const BASE_URL = import.meta.env.VITE_BACKEND_URL! || "";

const apiInstance = axios.create({
  baseURL: BASE_URL,
  withCredentials: true,
});

// Add an interceptor for error handling
apiInstance.interceptors.response.use(
  (response) => response, // Pass through successful responses
  (error) => {
    // Extract message from error
    const errorMessage =
      error.response?.data?.message || "An unexpected error occurred";
    appToast.error(errorMessage); // Show the error toast
    return Promise.reject(error); // Pass the error to the caller
  }
);

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // refetchOnWindowFocus: false,
      retry: false,
      queryFn: async ({ queryKey, signal }: QueryFunctionContext) => {
        const { data } = await apiInstance(`${queryKey[0]}`, { signal });
        return data;
      },
    },
  },
});

export default apiInstance;


src/hooks/use-mobile.tsx
------------------------
import * as React from "react";

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(
    undefined
  );

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);

  return !!isMobile;
}

const XL_BREAKPOINT = 1280;

export function useIsBeforeXl() {
  const [isBeforeXl, setIsBeforeXl] = React.useState<boolean | undefined>(
    undefined
  );

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${XL_BREAKPOINT}px)`);
    const onChange = () => {
      setIsBeforeXl(window.innerWidth < XL_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsBeforeXl(window.innerWidth < XL_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);

  return !!isBeforeXl;
}


src/hooks/useAdminAuth.ts
-------------------------
import { useEffect } from "react";
import { useApiQuery } from "./useApiQuery";
import { endpoints } from "@/api/endpoints";
import { useAdminAuthStore } from "@/stores/useAdminAuth";
import { useApiMutation } from "./useApiMutation";
import { queryClient } from "@/api/queryClient";

export function useAdminAuth() {
  const { user, setUser } = useAdminAuthStore();

  // 1️⃣ Load “me”
  const { data, isLoading, isError, refetch } = useApiQuery(endpoints.adminMe, {
    refetchInterval: 1000 * 60, // 1 minute
  });

  useEffect(() => {
    if (!data) return;
    setUser(data?.data?.data);
  }, [data, setUser]);

  // 2️⃣ Logout
  const { mutateAsync: logout } = useApiMutation<void, void>({
    route: endpoints.adminLogout,
    method: "POST",
    onSuccess: () => {
      queryClient.invalidateQueries(endpoints.adminMe);
      setUser(null);
      window.location.href = "/admin/login";
    },
  });

  return { user, isLoading, isError, refetch, logout };
}


src/hooks/useApiQuery.ts
------------------------
import { useQuery, UseQueryOptions } from "@tanstack/react-query";
import apiInstance, { BASE_URL } from "../api/queryClient";

export const useApiQuery = (
  route: string,
  options?: UseQueryOptions<any, any>
) => {
  return useQuery({
    queryKey: [route],
    queryFn: async () => {
      const response = await apiInstance.get(`${BASE_URL}${route}`);
      return response;
    },
    ...options,
  });
};


src/hooks/useApiMutation.ts
---------------------------
import { useMutation, UseMutationOptions } from "@tanstack/react-query";
import apiInstance from "../api/queryClient";
import { appToast } from "@/utils/toast";

export const useApiMutation = <TData, TResponse>({
  route,
  method = "POST",
  onSuccess,
  onError,
}: {
  route: string;
  method: "POST" | "PATCH" | "DELETE" | "PUT"; // Restrict method to specific HTTP verbs
  options?: UseMutationOptions<TResponse, Error, TData>;
  onSuccess?: (data: TResponse) => void;
  onError?: (error: Error) => void;
}) => {
  return useMutation({
    mutationFn: async (newData) => {
      if (method === "POST") {
        const response = await apiInstance.post(route, newData);
        return response.data;
      } else if (method === "PATCH") {
        const response = await apiInstance.patch(route, newData);
        return response.data;
      } else if (method === "PUT") {
        const response = await apiInstance.put(route, newData);
        return response.data;
      } else if (method === "DELETE") {
        const response = await apiInstance.delete(route, { data: newData }); // Fixed DELETE syntax for sending body
        return response.data;
      }
    },
    onSuccess: (data) => {
      onSuccess?.(data);
    },
    onError: (error: any) => {
      // Extract error message
      const errorMessage =
        error?.response?.data?.message || "An unexpected error occurred";
      appToast.error(errorMessage); // Show error toast
      onError?.(error);
    },
  });
};


src/hooks/useApiInfiniteQuery.ts
--------------------------------
// src/hooks/useApiInfiniteQuery.ts
import {
  useInfiniteQuery,
  UseInfiniteQueryOptions,
} from "@tanstack/react-query";
import apiInstance from "@/api/queryClient";

// Standard shape for paginated responses
export type ApiInfiniteData<T> = {
  entries: T[];
  meta: {
    total: number;
    page: number;
    pageSize: number;
    totalPages: number;
  };
};

export function useApiInfiniteQuery<
  T,
  E = unknown,
  F extends Record<string, unknown> = Record<string, unknown>
>(
  route: string,
  filters?: F,
  pageSize = 50,
  options?: Omit<
    UseInfiniteQueryOptions<
      ApiInfiniteData<T>,
      E,
      ApiInfiniteData<T>, // <-- result must match returned value
      ApiInfiniteData<T>, // <-- result per page
      [string, F?] // queryKey type
    >,
    "queryKey" | "queryFn" | "getNextPageParam" | "initialPageParam"
  >
) {
  return useInfiniteQuery({
    queryKey: [route, filters] as const,
    queryFn: async ({ pageParam = 1, signal }) => {
      const params = { page: pageParam, pageSize, ...(filters ?? {}) };
      const res = await apiInstance.get<{ data: ApiInfiniteData<T> }>(route, {
        params,
        signal,
      });
      return res.data.data;
    },
    getNextPageParam: (last) =>
      last.meta.page < last.meta.totalPages ? last.meta.page + 1 : undefined,
    initialPageParam: 1,
    ...options,
  });
}


src/layouts/default-layout.tsx
------------------------------
import { ReactNode } from "react";
import {
  SidebarInset,
  SidebarProvider,
  SidebarTrigger,
} from "@/components/ui/sidebar";
import { ModeToggle } from "@/components/mode-toggle";
import { AppSidebar } from "@/components/app-sidebar";

// responsibility: To provide a default layout for the app
export default function DefaultLayout({ children }: { children: ReactNode }) {
  return (
    <div className="min-h-screen flex flex-col">
      <SidebarProvider>
        <AppSidebar />
        <SidebarInset>
          <header className="flex h-16 shrink-0 items-center gap-2 transition-[width,height] ease-linear group-has-[[data-collapsible=icon]]/sidebar-wrapper:h-12">
            <div className="flex items-center gap-2 px-4 w-full">
              <SidebarTrigger className="-ml-1" />

              <div className="ml-auto">
                <ModeToggle />
              </div>
            </div>
          </header>
          <div className="p-4 pt-0">{children}</div>
        </SidebarInset>
      </SidebarProvider>
    </div>
  );
}


src/layouts/private-route.tsx
-----------------------------
// src/layouts/private-route.tsx
import { ReactNode } from "react";
import { Navigate, useLocation } from "react-router-dom";
import { useAdminAuth } from "@/hooks/useAdminAuth";

// A simple full-screen spinner
function FullScreenLoader() {
  return (
    <div className="flex items-center justify-center h-screen">
      <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-gray-500"></div>
    </div>
  );
}

interface PrivateRouteProps {
  children: ReactNode;
}

export default function PrivateRoute({ children }: PrivateRouteProps) {
  const { user, isLoading } = useAdminAuth();
  const location = useLocation();

  if (isLoading) return <div>Loading admin…</div>;
  if (!user) return <Navigate to="/login" state={{ from: location }} replace />;
  return <>{children}</>;
}


src/lib/utils.ts
----------------
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


src/pages/login.tsx
-------------------
import { useState } from "react";
import { Navigate, useNavigate, useLocation } from "react-router-dom";
import { useApiMutation } from "@/hooks/useApiMutation";
import { endpoints } from "@/api/endpoints";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useAdminAuth } from "@/hooks/useAdminAuth";

export default function AdminLoginPage() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const { user, isLoading } = useAdminAuth();
  const navigate = useNavigate();
  const location = useLocation<{ from?: Location }>();
  const from = location.state?.from?.pathname || "/";

  const login = useApiMutation<
    { email: string; password: string },
    { isSuperAdmin: boolean }
  >({
    route: endpoints.adminLogin,
    method: "POST",
    onSuccess: () => {
      navigate(from, { replace: true });
    },
  });

  if (isLoading) return <p>Loading…</p>;
  if (user) return <Navigate to="/" replace />;

  return (
    <div className="flex items-center justify-center min-h-screen p-4">
      <div className="w-full max-w-md space-y-6">
        <h1 className="text-2xl font-bold text-center">Admin Login</h1>
        <Input
          type="email"
          placeholder="Email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
        <Input
          type="password"
          placeholder="Password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
        <Button
          className="w-full"
          onClick={() => login.mutate({ email, password })}
          disabled={login.isLoading}
        >
          {login.isLoading ? "Signing in…" : "Sign In"}
        </Button>
      </div>
    </div>
  );
}


src/pages/index.tsx
-------------------
import InfiniteSelect from "@/components/commons/selects/base/infinite-select";
import { CitySelect } from "@/components/commons/selects/city-select";
import CountrySelect from "@/components/commons/selects/country-select";
import { SlugCreatableSelect } from "@/components/commons/selects/slug-creatable-select";
import StateSelect from "@/components/commons/selects/state-select";
import { useState } from "react";

const IndexPage = () => {
  return (
    <div className="text-black">
      <div style={{ maxWidth: 420 }}>
        <h3>Select a city</h3>
        <CitySelect
          placeholder="Type to search cities…"
          onChange={(opt) => {
            // You already get a console.log from the component;
            // here’s where you can react to the selection:
            if (opt?.data) {
              // do something with opt.data (city/state/country)
              // e.g. save to form state, fire API, etc.
            }
          }}
        />
      </div>
      <div style={{ maxWidth: 420 }}>
        <h3>Select a city</h3>
        <StateSelect
          placeholder="Type to search states"
          onChange={(opt) => {
            // You already get a console.log from the component;
            // here’s where you can react to the selection:
            if (opt?.data) {
              // do something with opt.data (city/state/country)
              // e.g. save to form state, fire API, etc.
            }
          }}
        />
      </div>
      <div style={{ maxWidth: 420 }}>
        <h3>Select a city</h3>
        <CountrySelect
          placeholder="Type to search countries"
          onChange={(opt) => {
            // You already get a console.log from the component;
            // here’s where you can react to the selection:
            if (opt?.data) {
              // do something with opt.data (city/state/country)
              // e.g. save to form state, fire API, etc.
            }
          }}
        />
      </div>

      <div>
        <InfiniteSelect<{ _id: string; name: string }>
          route="/internal/preference/slugs"
          getFilters={(search) => ({ q: search })}
          mapItemToOption={(item) => ({
            value: item._id,
            label: item.name,
            data: item,
          })}
        />
      </div>

      <ExampleSlugForm />
    </div>
  );
};

export default IndexPage;

type SlugItem = { _id: string; name: string };
type Option = { value: string; label: string; data?: SlugItem };

function ExampleSlugForm() {
  const [selected, setSelected] = useState<Option | null>(null);

  return (
    <div className="space-y-4">
      <h2 className="text-lg font-semibold">Select or Create Slug</h2>

      <SlugCreatableSelect
        value={selected}
        onChange={(opt) => {
          console.log("Selected option:", opt);
          setSelected(opt);
        }}
        placeholder="Search or create slug..."
      />

      {selected && (
        <div className="mt-4 p-3 border border-white/10 rounded-md bg-white/5">
          <p className="text-sm text-white/70">Currently selected slug:</p>
          <p className="text-white font-semibold">{selected.label}</p>
        </div>
      )}
    </div>
  );
}


src/App.tsx
-----------
import { Suspense, useMemo } from "react";
import { useRoutes, useLocation } from "react-router-dom";
import routes from "~react-pages";
import PrivateRoute from "./layouts/private-route";
import DefaultLayout from "./layouts/default-layout";
import { useAdminAuth } from "./hooks/useAdminAuth";

export function App() {
  const location = useLocation();
  const { user } = useAdminAuth();
  const appRoutes = useRoutes(routes);

  const publicPaths = useMemo(() => ["/login"], []);

  const isPublic = publicPaths.includes(location.pathname);
  console.log("user", user);

  return (
    <div>
      <Suspense fallback={<p>Loading…</p>}>
        {isPublic ? (
          appRoutes
        ) : (
          <PrivateRoute>
            <DefaultLayout>{appRoutes}</DefaultLayout>
          </PrivateRoute>
        )}
      </Suspense>
    </div>
  );
}


src/stores/useAdminAuth.ts
--------------------------
import { create } from "zustand";

export interface AdminUser {
  id: string;
  email: string;
  isSuperAdmin: boolean;
}

interface AdminAuthState {
  user: AdminUser | null;
  setUser: (u: AdminUser | null) => void;
}

export const useAdminAuthStore = create<AdminAuthState>((set) => ({
  user: null,
  setUser: (user) => set({ user }),
}));


src/main.tsx
------------
import { BrowserRouter } from "react-router-dom";
import { createRoot } from "react-dom/client";
import { App } from "./App";
import { queryClient } from "./api/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { ThemeProvider } from "@/components/theme-provider";
import { Toaster } from "react-hot-toast";
import "./index.css";

const app = createRoot(document.getElementById("root")!);

app.render(
  <QueryClientProvider client={queryClient}>
    <BrowserRouter>
      <ThemeProvider defaultTheme="dark" storageKey="vite-ui-theme">
        <Toaster />
        <App />
      </ThemeProvider>
    </BrowserRouter>
  </QueryClientProvider>
);
